<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Whisperd</title>
    <link>https://dashengsun.github.io/</link>
    <description>Recent content on Whisperd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Oct 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://dashengsun.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Understand Monad in Functional Programming</title>
      <link>https://dashengsun.github.io/post/understand-monad/</link>
      <pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/understand-monad/</guid>
      <description>[TOC]
Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have Procedure-oriented programming. As the system becomes bigger and bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet.</description>
    </item>
    
    <item>
      <title>Understanding smart contracts</title>
      <link>https://dashengsun.github.io/post/solidity-basics/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/solidity-basics/</guid>
      <description>Concepts Demo Embark integrate with Ethereum, IPFS, etc.
Reference https://embark.status.im/docs/setup.html
https://medium.com/@ConsenSys/a-101-noob-intro-to-programming-smart-contracts-on-ethereum-695d15c1dab4
https://github.com/AugurProject/augur-core</description>
    </item>
    
    <item>
      <title>Kubernetes basics</title>
      <link>https://dashengsun.github.io/post/kubernetes-basics/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/kubernetes-basics/</guid>
      <description>Background &amp;amp; why kubernetes Micro services Usually we build a single &amp;ldquo;monolith&amp;rdquo; application at first time. As the business grows, the app becomes &amp;ldquo;heavy&amp;rdquo; and hard to maintain:
 Improved cost to communicate within different teams; Long enough time to finish the CI pipeline(run the test cases, packages, deployment); Hard to scale; &amp;hellip;  So we need to make big application to be small different services depends on a few principles, that&amp;rsquo;s micro services.</description>
    </item>
    
    <item>
      <title>如何部署 IOTA 的 IRI headless 全节点</title>
      <link>https://dashengsun.github.io/post/how-to-setup-iri/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/how-to-setup-iri/</guid>
      <description>什么是 IOTA IOTA 的设计初衷是面向未来的机器与机器、人与人、人与机器之间点对点互联互通的DLT（分布式账本技术）协议。
通过利用DAG实现了无交易费、高TPS，将whisper protocol用于消息传递，有效提高消息的可达性和私密性。
本文所关注的IRI (IOTA Reference implementation)是IOTA协议Java版本的实现，基于Rust的版本正在开发之中。
部署 IRI headless 全节点 服务器选择 目前国内的服务器提供商包括阿里云，华为，青云等， 国外的有AWS，GCP（谷歌云服务），digital ocean等，价格不等，配置大同小异，本文将会以阿里云为例。
运行 IRI 全节点配置至少是:
 1vCPU
 4G 内存
 1M 带宽
 硬盘40G目前是足够的，可以按需添加数据盘
 ECS 实例规格应为独享
  操作系统选择适合自己的Linux发行版，建议使用每种发行版的最新版本，如Ubuntu 16.04。
本文所使用配置，如下图： 服务器的基础环境准备 1.安装Git，在IRI搭建时并没有用到，之后tangle网络生成snapshot时需要：
sudo apt-get update sudo apt-get install git  2.安装screen，管理服务器终端产生的session
sudo apt-get install screen  3.安装Java， Oracle JDK，添加Oracle的包管理仓库并更新，
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update  安装JDK8，
sudo apt-get install oracle-java8-installer  查看安装，</description>
    </item>
    
    <item>
      <title>理解Golang并发编程</title>
      <link>https://dashengsun.github.io/post/go-channel/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/go-channel/</guid>
      <description>concurrency vs parallelism 并发和并行是彼此相关的两个概念，并不能完全等价。
在程序中，并发强调的是独立执行的程序的组合；并行强调的是同时执行计算任务[1]。
计算机核心的数量决定了并行计算的能力，大多数人类作为“单核”动物(老顽童小龙女除外)，可以说自己在并发某些任务，如我在听歌写代码，但是不能说这两件事在并行，参考下图：
Golang的并发模型源于Communicating Sequential Processes (CSP)，通过提供goroutine和channel来实现并发编程模式。
Goroutine Goroutine由Go运行时创建和管理，是用于调度CPU资源的“最小单元”，和OS的线程相比更轻量[2]:
 内存消耗更低只需2kB初始栈空间，而线程初始要1Mb的空间； 由golang的运行时环境创建和销毁，更加廉价，不支持手动管理； 切换效率更高等。 Goroutine和线程的关系如下图所示：  我们可以轻松地创建成百上千的goroutine，而不会降低程序的执行效率。
通过goroutine可以让一个函数和其他的函数并行执行。可以在函数调用前面加上go关键字，方便地创建一个goroutine。
main函数本身也是一个goroutine[3]。
举例如下：
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;begin main goroutine&amp;quot;) go hello() fmt.Println(&amp;quot;end main goroutine&amp;quot;) } func hello() { fmt.Println(&amp;quot;begin hello goroutine&amp;quot;) }  输出：
begin main goroutine end main goroutine  上面的例子中，并不会输出begin hello goroutine，这是因为， 通过使用goroutine，我们不需要等待函数调用的返回结果，而会接着执行下面的代码。
可以在go hello()后面添加：
time.Sleep(1 * time.Second)  就可以正常输出begin hello goroutine。
channel Go提供了一种机制能够使goroutine之间进行通信和同步，它就是channel。</description>
    </item>
    
    <item>
      <title>Golang web 开发</title>
      <link>https://dashengsun.github.io/post/golang-docker-ci/</link>
      <pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/golang-docker-ci/</guid>
      <description>背景 Web应用长期以来是Ruby、Java、PHP等开发语言的战场。
 Ruby可以实现快速原型开发，Ruby On Rails “全能”框架实现“全栈”开发，缺点有大型应用性能差、调试困难； Java 20多年的发展历程，各种第三方库、框架健全，运行效率高， 但是随着应用的功能膨胀，臃肿的get/set方法，JVM占用大量计算机资源、性能调试困难，函数式编程不友好。 PHP，TL;DR  本文实现了一个最小化web应用，以此来了解Golang web的生态，通过使用Docker隔离开发环境， 使用Posgres持久化数据，源代码请参考这里
Why Go?  性能优越 部署简单，只需要将打包好的二进制文件部署到服务器上 内置丰富的标准库，让程序员的生活变得简单美好 静态语言，类型检查 duck typing goroutine将开发人员从并发编程中解放出来 函数作为“一等公民” &amp;hellip;  Golang第三方框架选择  Web框架: Gin，性能卓越，API友好，功能完善 ORM: GORM,支持多种主流数据库方言，文档清晰 包管理工具: Glide,类似于Ruby的bundler或者NodeJS中的npm 测试工具:    GoConvey,符合BDD测试风格,支持浏览器测试结果的可视化 Testify,提供丰富的断言和Mock功能    数据库migration: migrate 日志工具: Logrus,结构化日志输出，完全兼容标准库的logger  Dockerize 开发环境 发布应用 base image Dockerfile如下:
FROM golang:1.8 # 包管理工具 RUN curl https://glide.sh/get | sh # 代码热加载 RUN go get github.</description>
    </item>
    
    <item>
      <title>理解 Javascript 的几种异步模式</title>
      <link>https://dashengsun.github.io/post/callback-promise/</link>
      <pubDate>Wed, 05 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/callback-promise/</guid>
      <description>Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念  栈(Stack)  和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
  单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件    堆(Heap)  堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
 事件队列(event queue)  当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
 Event loop  Event loop将event queue中按照&amp;rdquo;FIFO&amp;rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); }  Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&amp;rdquo;一等公民&amp;rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console.</description>
    </item>
    
    <item>
      <title>Hackday是一种怎样的体验？</title>
      <link>https://dashengsun.github.io/post/hackday/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/hackday/</guid>
      <description>加入 Thoughtworks 之后，经历了REA (realestate.com.au) 三次 Hackday，感受一次比一次强烈，我觉得有必要和大家分享一下这么优秀的想法和活动。
什么是 hackday？ Hackday，有时也被叫做 Hackathon，是IT行业一个类似于“百米冲刺”的活动，主要目的在于围绕一个主题，进行软件设计和开发，持续时间不等，可以是一天，也可以是一周，以2~3天为多数。活动范围有企业内部、社区等。
REA的 hackday 长什么样？ 在 REA，协作和创新被视为企业的灵魂，每个季度会举办一次hackday，为期三天，除非有相当紧急的线上问题需要处理，一般来说，大部分人都是能够参与其中的。很难想象一个公司所有人三天里都在搞“飞机”，不干“正事”，但是这不也正体现了一个企业的文化、魄力和产品的稳定性吗？ hackday 流程大致是这样的，
 团队内部 brain storm，收集 idea； 投票选出意向参与的项目，分配资源； 公司范围的 Stand up，阐述 idea，并找到目标资源（UX，前端Dev，后端Dev，等等） 团队内部 Kick off，划分 story MVP 功能开发（结对编程），一般为 1.5~2天 制作 Showcase 海报 公司范围 Showcase 拉票，投票 根据项目的情况，少数会进入产品，多数会成为工作生活的小助手，解决工作生活中的痛点。  我参与的 hackday 项目 印象比较深刻的是4个:
 CI 监控  REA很多CI跑在 Bamboo 和 Buildkite上，每个平台提供的监控数据和展示层不能整合，其中一次hackday，我们就自己动手去整合两个平台的数据，外加一个数据展示的web页面，加上炫酷的动画，完美~ 并且成功的在最近一次hackday前“卖”给了别的team。
 Slack robot  监控红了，build 挂了，总得人来修吧，但是这个人呢，太忙，又或者不知道是自己在值班，怎么办呢，我们就让一个robot定时去拉build的状态，一旦红了，去slack上@他，叫醒他，“嘿，哥们，你不修，你好意思吗?”
 奔跑吧，会员卡  每当我走进xx超市、xx火锅，结账那一刻，我是拒绝的，尼玛这么点东西，怎么这么贵？现在好了， 我们搞了VIP会员卡共享的公众号，可以注册登记每个人的会员卡，可以供大家查询使用。虽然还有很多功能需要完善，但是我们已经迈出了一大步，对吗？PS: 公众号还在公司内测，一旦公开第一时间跟大家分享。
 Gulugulu  用过 Bilibili 吧，弹幕啊，吐槽啊，段子手啊，想象一下大家一起吐槽百度主站的情形， 一个字形容，爽。Gulugulu就有这样的功能，只要引入一个Javascript文件，done。具体请参考Github gulugulu和gulugulu-chrome。</description>
    </item>
    
    <item>
      <title>使用 Hexo 搭建个人博客</title>
      <link>https://dashengsun.github.io/post/hexo/</link>
      <pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dashengsun.github.io/post/hexo/</guid>
      <description>Hexo 是一个博客框架,支持Markdown,通过命令行可以快速部署, 有大量的主题和插件,让你的blog飞起来&amp;hellip;
安装 Hexo sudo npm install -g hexo-cli hexo -v  创建 Github blog project 个人习惯将source和deploy分开,在github上创建一个blog项目(保存源文件)和 xxx.github.io项目(用于部署Github个人主页,xxx为用户名,具体参考Github Pages)
hexo init blog cd blog npm install  Run server $ hexo s  More info: Server
设置博客页个人信息 我的配置文件 _config.yml
# Site title: Whisperd subtitle: description: make a difference author: kaichao language: timezone: Asia/Shanghai # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: https://dashengsun.</description>
    </item>
    
  </channel>
</rss>